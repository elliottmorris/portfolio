<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>What can we learn from election forecasting?</title>
    <meta charset="utf-8" />
    <meta name="author" content="G. Elliott Morris  Data journalist  The Economist" />
    <meta name="date" content="2020-09-24" />
    <script src="libs/header-attrs-2.3/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/robot.css" rel="stylesheet" />
    <link rel="stylesheet" href="my-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# What can we learn from election forecasting?
### <strong>G. Elliott Morris</strong> <br />Data journalist <br /><em>The Economist</em>
### September 24, 2020

---




# Personal info (to break up zoom awkwardness):


- I graduated from the University of Texas at Austin (Hook’em!) in 2018 (so I’m not that much older than y’all)
- I studied government and history with computer science and statistics on the side (AKA you never know what you might end up doing with your education)
- I live in Washington, DC with my fiance and two cats (bacon and pancake)
- I’m a data journalist for The Economist
  - I’ve worked on all sorts of projects and pieces
  - But my expertise is in public opinion polling and election forecasting
- Aside from my work at The Economist I also interned with the Pew Research Center on their survey methods team


---

class: center, inverse

# &amp;nbsp;
# &amp;nbsp;
# Let's talk forecasting


---

![](figures/forecast_sept_23.png)


---

# What we learn from building election forecasts

Primarily useful as tools for handicapping the horse race

But also let us test theories about voter behavior and the forces guiding out politics:
- The role of economics in shaping presidential evaluations
- The extent to which presidential approval shapes future evaluations of the incumbent party (IE over the course of the election year)
- Whether non-incumbent parties are treated differently (they are)

And they enable us to test hypothesis about the accuracy of different polling methods
- Polls provide regular benchmarks against methodological choices
- Such as sampling procedures, weighting modes, etc

And about structural factors
- Is the electoral college biased toward Republicans? White voters? 
- By how much?


---

# The “fundamentals” part 1: economics + incumbency

![](figures/fundamentals.png)


---

# The “fundamentals” part 2: approval + incumbency

![](figures/fundamentals.png)


---

class: center, inverse

# &amp;nbsp;
# &amp;nbsp;
# Break for questions

---

# Polls (and what forecasting teaches us about them)


Polls provide regular benchmarks against methodological choices

Poll-level model for aggregating opinions
- Includes a variable for differences from mode (online/IVR/live phone)
- Includes a variable for differences from population (likely/registered voters)
- (Regular departure from the average of polls bias)

Such as weighting variables, etc
- Time-series model
  - Creates two averages: one for pollsters who use the correct weighting protocols and one for those that don’t
  - Pushes the adjusted average for pollsters who don’t weight correctly back toward the other


---

class: center, inverse

# &amp;nbsp;
# &amp;nbsp;
# Break for questions

---

# Learning from predictions: electoral college bias

![](figures/electoral_college_curve.png)

---

![](figures/electoral_college_map.png)


---

![](figures/ec_white_voters.png)


---

![](figures/states_turnout.png)


---

class: center, inverse

# &amp;nbsp;
# &amp;nbsp;
# Q&amp;A time



---

class: center

# Thank you!

&amp;nbsp;

## G. Elliott Morris
### Data journalist, _The Economist_

**Website: [gelliottmorris.com](https://www.gelliottmorris.com)**

**Email: [elliott@thecrosstab.com](mailto:elliott@thecrosstab.com)**

**Twitter: [@gelliottmorris](http://www.twitter.com/gelliottmorris)**

--- 

_These slides were made with the `xaringan` package for R from Yihui Xie. They are available online at https://www.gelliottmorris.com/slides/2020-09-24-cornell-kreps/_
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
